{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"+FAkBE,AAAY,WAJG,EAAS,GAAI,SATa,AAAxB,EAAU,YA8B3B,AAAwB,IACxB,EAAK,AAAY,MAAG,EAAQ,QAAe,EACzC,AAAc,EAAQ,KAAmB,gBACzC,AAAI,EAAY,KAAG,GAGnB,EAAK,AAAY,MAAG,EAAI,MAAQ,EAC9B,AAAuB,AAAW,EAAS,MAC3C,AAAI,EAAqB,KAAG,GAC5B,AACE,EAAQ,KAAkB,cAAsB,OAChD,EAAQ,KAAkB,cAAsB,cAChD,EAAQ,KAAqB,cAAsB,YAEnD,AAAoB,IACpB,EAAK,AAAe,MAAG,EAAO,MAAW,EACvC,AAAiB,AAAW,EAAkB,MAC9C,AAAI,EAAe,KAAG,GACtB,AAAI,EAAQ,KAAkB,KAhDG,AAAxB,EAAU,OAgD2B,KAC5C,OACA,AAAI,EAAkB,KACpB,AAAgB,IAChB,KAP2B,aAWjC,AAAI,EAAgB,KACT,KAAqB,KAAkB,cACvC,KAAsB,KArDvC,AAAW,EAAU,GAAgB,KAsD7B,AAAoB,EAAoB,QAvBnB,cALK","sourceRoot":"assemblyscript:///","sourceContents":["@external(\"console\", \"logger\")\ndeclare function logger(offset: usize): void\n\n@inline\nfunction loadBit(offset: u32): u32 {\n  return load<u32>(offset << alignof<u32>());\n}\n\n@inline\nfunction storeBit(offset: u32, value: u32): void {\n  store<u32>(offset << alignof<u32>(), value);\n}\n\nfunction loadCopper(offset: u32, pos: u8): u32 {\n  return loadBit(offset * 8 + pos);\n}\n\nexport function init(): void {\n  memory.grow(800);\n}\n\nexport function tick(): void {\n  const size = 605129;\n  const coppersSize = size * 8;\n  const headsArrayOffset = coppersSize + size * 1;\n  const tailsArrayOffset = coppersSize + size * 3;\n  const headsGridOffset = coppersSize + size * 2;\n  const tailsGridOffset = coppersSize + size * 4;\n\n  const newHeadsArrayOffset = coppersSize + size * 5;\n  const newTailsArrayOffset = coppersSize + size * 7;\n  const newHeadsGridOffset = coppersSize + size * 6;\n  const newTailsGridOffset = coppersSize + size * 8;\n\n  /**/\n  let newHeadArrayIndex = 0;\n  for (let index = 0; index < size; index++) {\n    let headKey = loadBit(headsArrayOffset + index);\n    if (headKey === 0) {\n      break;\n    }\n    for (let i: u8 = 0; i < 8; i++) {\n      let copperStateIndex = loadCopper(headKey, i);\n      if (copperStateIndex === 0) break;\n      if (\n        loadBit(tailsGridOffset + copperStateIndex) === 0 &&\n        loadBit(headsGridOffset + copperStateIndex) === 0 &&\n        loadBit(newHeadsGridOffset + copperStateIndex) === 0\n      ) {\n        let headNeighbors = 0;\n        for (let ind2: u8 = 0; ind2 < 8; ind2++) {\n          let stateIndex = loadCopper(copperStateIndex, ind2);\n          if (stateIndex === 0) break;\n          if (loadBit(headsGridOffset + stateIndex) === 1) {\n            headNeighbors++;\n            if (headNeighbors === 3) {\n              headNeighbors = 0;\n              break;\n            }\n          }\n        }\n        if (headNeighbors > 0) {\n          storeBit(newHeadsGridOffset + copperStateIndex, 1);\n          storeBit(newHeadsArrayOffset + newHeadArrayIndex, copperStateIndex);\n          newHeadArrayIndex = newHeadArrayIndex + 1;\n        }\n      }\n    }\n  }\n\n/*\n  for (let i = headsArrayOffset, j = 0, l = headsGridOffset + size; i < l; i++, j++) {\n    storeBit(newTailsArrayOffset + j, loadBit(i));\n  }\n\n  for (let i = newHeadsArrayOffset, j = 0, l = newHeadsArrayOffset + size * 4 + size * 4; i < l; i++, j++) {\n    storeBit(headsArrayOffset + j, loadBit(i));\n  }\n*/\n\n  /*\n    this.mem32.copyWithin(newTailsArrayOffset, headsArrayOffset, headsGridOffset + size);\n    this.mem32.copyWithin(headsArrayOffset, newHeadsArrayOffset, newHeadsArrayOffset + size * 4 + size * 4);\n  */\n\n\n}\n\n"]}
{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"uFAkBE,AAAY,SAb6B,AAAxB,AASF,AAAa,MAAb,EAAS,IATG,cA+B3B,EAAoB,EAAQ,OAEP,AADnB,AAAsB,AAAmB,EAAnB,iBAIjB,AAAY,MAAjB,EAAoB,EAAI,KAEM,AAD5B,AAAuB,AAAW,EAAS,SAE3C,AACE,AAAQ,AAAkB,EAAlB,iBACA,AAAkB,EAAlB,qBACA,AAAqB,EAArB,mBAER,AAAoB,IACf,AAAe,MAApB,EAAuB,EAAO,KAEN,AADtB,AAAiB,AAAW,EAAkB,SAE9C,AAAI,AAhD6B,AAAxB,AAgDG,AAAkB,EAAlB,MAhDO,MAgD2B,KAE5C,AAAI,AADJ,OACsB,KACpB,AAAgB,IAChB,IAP2B,WAWjC,AAAI,EAAgB,KACT,AAAqB,EAArB,SAAuC,KApDxD,AAAW,AAqDM,AAAsB,EAAtB,MArDI,GAAgB,KAsD7B,AAAoB,EAAoB,OAvBnB,WALK","sourceRoot":"assemblyscript:///","sourceContents":["@external(\"console\", \"logger\")\r\ndeclare function logger(offset: usize): void\r\n\r\n@inline\r\nfunction loadBit(offset: u32): u32 {\r\n  return load<u32>(offset << alignof<u32>());\r\n}\r\n\r\n@inline\r\nfunction storeBit(offset: u32, value: u32): void {\r\n  store<u32>(offset << alignof<u32>(), value);\r\n}\r\n\r\nfunction loadCopper(offset: u32, pos: u8): u32 {\r\n  return loadBit(offset * 8 + pos);\r\n}\r\n\r\nexport function init(): void {\r\n  memory.grow(800);\r\n}\r\n\r\nexport function tick(): void {\r\n  const size = 605129;\r\n  const coppersSize = size * 8;\r\n  const headsArrayOffset = coppersSize + size * 1;\r\n  const tailsArrayOffset = coppersSize + size * 3;\r\n  const headsGridOffset = coppersSize + size * 2;\r\n  const tailsGridOffset = coppersSize + size * 4;\r\n\r\n  const newHeadsArrayOffset = coppersSize + size * 5;\r\n  const newTailsArrayOffset = coppersSize + size * 7;\r\n  const newHeadsGridOffset = coppersSize + size * 6;\r\n  const newTailsGridOffset = coppersSize + size * 8;\r\n\r\n  /**/\r\n  let newHeadArrayIndex = 0;\r\n  for (let index = 0; index < size; index++) {\r\n    let headKey = loadBit(headsArrayOffset + index);\r\n    if (headKey === 0) {\r\n      break;\r\n    }\r\n    for (let i: u8 = 0; i < 8; i++) {\r\n      let copperStateIndex = loadCopper(headKey, i);\r\n      if (copperStateIndex === 0) break;\r\n      if (\r\n        loadBit(tailsGridOffset + copperStateIndex) === 0 &&\r\n        loadBit(headsGridOffset + copperStateIndex) === 0 &&\r\n        loadBit(newHeadsGridOffset + copperStateIndex) === 0\r\n      ) {\r\n        let headNeighbors = 0;\r\n        for (let ind2: u8 = 0; ind2 < 8; ind2++) {\r\n          let stateIndex = loadCopper(copperStateIndex, ind2);\r\n          if (stateIndex === 0) break;\r\n          if (loadBit(headsGridOffset + stateIndex) === 1) {\r\n            headNeighbors++;\r\n            if (headNeighbors === 3) {\r\n              headNeighbors = 0;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (headNeighbors > 0) {\r\n          storeBit(newHeadsGridOffset + copperStateIndex, 1);\r\n          storeBit(newHeadsArrayOffset + newHeadArrayIndex, copperStateIndex);\r\n          newHeadArrayIndex = newHeadArrayIndex + 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n/*\r\n  for (let i = headsArrayOffset, j = 0, l = headsGridOffset + size; i < l; i++, j++) {\r\n    storeBit(newTailsArrayOffset + j, loadBit(i));\r\n  }\r\n\r\n  for (let i = newHeadsArrayOffset, j = 0, l = newHeadsArrayOffset + size * 4 + size * 4; i < l; i++, j++) {\r\n    storeBit(headsArrayOffset + j, loadBit(i));\r\n  }\r\n*/\r\n\r\n  /*\r\n    this.mem32.copyWithin(newTailsArrayOffset, headsArrayOffset, headsGridOffset + size);\r\n    this.mem32.copyWithin(headsArrayOffset, newHeadsArrayOffset, newHeadsArrayOffset + size * 4 + size * 4);\r\n  */\r\n\r\n\r\n}\r\n\r\n"]}
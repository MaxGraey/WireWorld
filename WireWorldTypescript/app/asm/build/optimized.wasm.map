{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"gFAkCE,AAAY,YAKZ,UACK,AAAiB,MAAtB,EAAyB,EAAS,KAEhC,AAA8B,AAD9B,AAAsB,AAAmB,wBAEpC,AAAY,MAAjB,EAAoB,EAAI,KAEtB,AACE,AAAQ,AAFV,wCAGU,AAAkB,uBAClB,AAAqB,qBAE7B,AAAoB,IACpB,AAA+B,UAC1B,AAAe,MAApB,EAAuB,EAAO,KAE5B,AAAI,AAlC6B,AAAxB,AAkCG,AAxBL,AAAqB,MAArB,MAA2B,eAVf,MAkC2B,KAE5C,AAAI,AADJ,OACsB,KACpB,AAAgB,IAChB,IANqC,WAU3C,AAAI,EAAgB,KACT,AAAqB,WAAkB,KACjB,gBAC/B,AAAoB,EAAoB,OAtBV,WAHE,WAfxC,KAAqC","sourceRoot":"assemblyscript:///","sourceContents":["@external('console', 'logger')\r\ndeclare function logger(offset: usize): void\r\n\r\nconst copperLen: u32 = 8;\r\nconst size = 605129;\r\nconst arrLen = 7000;\r\nconst coppersSize = size * copperLen;\r\nconst headsArrayOffset = coppersSize + size;\r\nconst headsGridOffset = headsArrayOffset + arrLen;\r\nconst tailsArrayOffset = headsGridOffset + size;\r\nconst tailsGridOffset = tailsArrayOffset + arrLen;\r\n\r\nconst newHeadsArrayOffset = tailsGridOffset + size;\r\nconst newHeadsGridOffset = newHeadsArrayOffset + arrLen;\r\nconst newTailsArrayOffset = newHeadsGridOffset + size;\r\nconst newTailsGridOffset = newTailsArrayOffset + arrLen;\r\n\r\n\r\n@inline\r\nfunction loadBit(offset: u32): u32 {\r\n  return load<u32>(offset << alignof<u32>());\r\n}\r\n\r\n@inline\r\nfunction storeBit(offset: u32, value: u32): void {\r\n  store<u32>(offset << alignof<u32>(), value);\r\n}\r\n\r\n@inline\r\nfunction loadCopper(offset: u32, pos: u8): u32 {\r\n  return loadBit(offset * copperLen + pos + 1);\r\n}\r\n\r\nexport function init(): void {\r\n  memory.grow(800);\r\n}\r\n\r\nexport function tick(): void {\r\n  let newHeadArrayIndex = 0;\r\n  let hLen: u32 = loadBit(headsArrayOffset);\r\n  for (let index: u32 = 1; index <= hLen; index++) {\r\n    let headKey = loadBit(headsArrayOffset + index);\r\n    let hCopperLen: u32 = loadBit(headKey * copperLen);\r\n    for (let i: u8 = 0; i < hCopperLen; i++) {\r\n      let copperStateIndex = loadCopper(headKey, i);\r\n      if (\r\n        loadBit(tailsGridOffset + copperStateIndex) === 0 &&\r\n        loadBit(headsGridOffset + copperStateIndex) === 0 &&\r\n        loadBit(newHeadsGridOffset + copperStateIndex) === 0\r\n      ) {\r\n        let headNeighbors = 0;\r\n        let hnCopperLen: u32 = loadBit(copperStateIndex * copperLen);\r\n        for (let ind2: u8 = 0; ind2 < hnCopperLen; ind2++) {\r\n          let stateIndex = loadCopper(copperStateIndex, ind2);\r\n          if (loadBit(headsGridOffset + stateIndex) === 1) {\r\n            headNeighbors++;\r\n            if (headNeighbors === 3) {\r\n              headNeighbors = 0;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (headNeighbors > 0) {\r\n          storeBit(newHeadsGridOffset + copperStateIndex, 1);\r\n          storeBit(newHeadsArrayOffset + newHeadArrayIndex + 1, copperStateIndex);\r\n          newHeadArrayIndex = newHeadArrayIndex + 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  storeBit(newHeadsArrayOffset, newHeadArrayIndex);\r\n}\r\n"]}